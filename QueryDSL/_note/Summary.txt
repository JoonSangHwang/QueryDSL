* Code Generation
  Gradle > Tasks > other > compileQuerydsl

* Dependencies
  - com.querydsl:querydsl-apt
    : Q코드 생성 해주는 라이브러리

  - com.querydsl:querydsl-jpa
    : 쿼리를 만들어주는 라이브러리

* QueryDSL 장점

* JPQL vs Querydsl


* JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까?
  - 동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다.
    스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도,
    트랜잭션 마다 별도의 속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱 정하지 않아도 된다.


* Entitymanager 는 Thread 에 safe 한가?
  - 엔티티매니저는 thread safe 할 수도 있고 안할 수도 있습니다.
    순수하게 자바환경에서 직접 엔티티메니저를 사용하면 쓰레드 세이프 하지 않습니다.
    그런데 스프링 컨테이너를 포함한 J2EE 컨테이너들은 JPA 표준 스펙에 맞추어서 주입받은 엔티티매니저가 쓰레드 세이프 하도록 되어 있습니다.
    쉽게 이야기해서 성경님이 말씀하신 것 처럼 스프링 컨테이너가 쓰레드 세이프하게 관리해주는게 맞습니다.
    조금 더 자세한 내용은 JPA 책 13.1 트랜잭션 범위를 참고.


* Q클래스 인스턴스를 사용하는 2가지 방법
  1.별칭 직접 지정
    QMember qMember = new QMember("m");
  2-1.기본 인스턴스 사용
    QMember qMember = QMember.member;
  2-2.기본 인스턴스의 import static 사용 (추천)
    import static com.joonsang.example.QueryDSL.entity.QMember.*;

* QueryDSL 의 쿼리문
  - QueryDSL 은 JPQL 빌더 역할로 결국 JPQL 로 쿼리가 실행된다.
    기존 설정으로는 쿼리문만 확인을 할 수 있으며, QueryDSL 로 작성 된 JPQL 쿼리 확인을 위해서는 아래와 같은 설정을 넣어주면 된다.
  - spring.jpa.properties.hibernate.use_sql_comments = true
  - 참고로, JPQL 쿼리문에서의 Alias 는 Q클래스 들어가보면 확인 할 수 있는데...
    같은 테이블을 Join 할 경우 겹치니까 Q클래스 인스턴스를 1번 방법으로 사용하자