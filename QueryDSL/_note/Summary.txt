* Code Generation
  Gradle > Tasks > other > compileQuerydsl

* Dependencies
  - com.querydsl:querydsl-apt
    : Q코드 생성 해주는 라이브러리

  - com.querydsl:querydsl-jpa
    : 쿼리를 만들어주는 라이브러리

* QueryDSL 장점

* JPQL vs Querydsl


* JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까?
  - 동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다.
    스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도,
    트랜잭션 마다 별도의 속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱 정하지 않아도 된다.


* Entitymanager 는 Thread 에 safe 한가?
  - 엔티티매니저는 thread safe 할 수도 있고 안할 수도 있습니다.
    순수하게 자바환경에서 직접 엔티티메니저를 사용하면 쓰레드 세이프 하지 않습니다.
    그런데 스프링 컨테이너를 포함한 J2EE 컨테이너들은 JPA 표준 스펙에 맞추어서 주입받은 엔티티매니저가 쓰레드 세이프 하도록 되어 있습니다.
    쉽게 이야기해서 성경님이 말씀하신 것 처럼 스프링 컨테이너가 쓰레드 세이프하게 관리해주는게 맞습니다.
    조금 더 자세한 내용은 JPA 책 13.1 트랜잭션 범위를 참고.


* Q클래스 인스턴스를 사용하는 2가지 방법
  1.별칭 직접 지정
    QMember qMember = new QMember("m");
  2-1.기본 인스턴스 사용
    QMember qMember = QMember.member;
  2-2.기본 인스턴스의 import static 사용 (추천)
    import static com.joonsang.example.QueryDSL.entity.QMember.*;

* QueryDSL 의 쿼리문
  - QueryDSL 은 JPQL 빌더 역할로 결국 JPQL 로 쿼리가 실행된다.
    기존 설정으로는 쿼리문만 확인을 할 수 있으며, QueryDSL 로 작성 된 JPQL 쿼리 확인을 위해서는 아래와 같은 설정을 넣어주면 된다.
  - spring.jpa.properties.hibernate.use_sql_comments = true
  - 참고로, JPQL 쿼리문에서의 Alias 는 Q클래스 들어가보면 확인 할 수 있는데...
    같은 테이블을 Join 할 경우 겹치니까 Q클래스 인스턴스를 1번 방법으로 사용하자

* QueryDSL 검색 조건
  - 메서드 체인
    .and()
    .or()
  - 검색 조건
    .eq("A")                  == A
    .ne("A")                  != A
    .eq("A").not()            != A
    .goe(1)                   >= 1
    .gt(1)                    >  1
    .loe(1)                   <= 1
    .lt(1)                    <  1
    .isNotNull()              is not null
    .in("A", "B")             in ("A", "B")
    .notIn("A", "B")          not in ("A", "B")
    .between("A", "B")        between
    .like("A%")               Like "A%"
    .contains("A")            Like "%A%"
    .startsWith("A")          Like "A%"

* QueryDSL 결과 조회
  - fetch()         : 리스트 조회, 데이터 없으면 빈 리스트 반환
  - fetchOne()      : 단 건 조회 (결과가 없으면 : null / 결과가 둘 이상이면 : com.querydsl.core.NonUniqueResultException)
  - fetchFirst()    : limit(1).fetchOne()
  - fetchResults()  : 페이징 정보 포함, total count 쿼리 추가 실행
  - fetchCount()    : count 쿼리로 변경해서 count 수 조회

* QueryDSL 정렬
  - desc(), asc()               : 일반 정렬
  - nullsLast(), nullsFirst()   : null 데이터 순서 부여

* QueryDSL 페이징 count 쿼리 성능 주의
  - 실무에서 페이징 쿼리를 작성할 때, 데이터를 조회하는 쿼리는 여러 테이블을 조인해야 하지만, count 쿼리는 조인이 필요 없는 경우도 있다.
    그런데 이렇게 자동화된 count 쿼리는 원본 쿼리와 같이 모두 조인을 해버리기 때문에 성능이 안나올 수 있다.
    count 쿼리에 조인이 필요없는 성능 최적화가 필요하다면, count 전용 쿼리를 별도로 작성해야 한다.

* Join
  - join(), innerJoin(): 내부 조인
  - leftJoin(): left 외부 조인
  - rightJoin(): rigth 외부 조인
  - theta_join(): 세타 조인 (연관관계가 없는 필드로 조인)

* on
  - on 절을 활용해 조인 대상을 필터링 할 때, 외부조인이 아니라 내부조인(inner join)을 사용하면, where 절에서 필터링 하는 것과 기능이 동일하다.
    따라서 on 절을 활용한 조인 대상 필터링을 사용할 때, 내부조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하자.
  - 하이버네이트 5.1부터 on을 사용해서 서로 관계가 없는 필드로 외부 조인하는 기능이 추가되었다. 물론 내부 조인도 가능하다

* fetch join
  - 페치 조인은 SQL에서 제공하는 기능 X. SQL조인을 활용해서 연관된 엔티티를 SQL 한번에 조회하는 기능이다. 주로 성능 최적화에 사용하는 방법